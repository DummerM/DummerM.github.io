import{_ as i,c as s,o as e,a3 as a}from"./chunks/framework.CkL4CRoQ.js";const E=JSON.parse('{"title":"CSS优化合集","description":"","frontmatter":{"title":"CSS优化合集","date":"2022-07-28T00:00:00.000Z","sidebar":"auto","tags":["CSS"],"categories":["前端"]},"headers":[],"relativePath":"front/css/CSSOptimizationAndImprovement.md","filePath":"front/css/CSSOptimizationAndImprovement.md","lastUpdated":1715845410000}'),l={name:"front/css/CSSOptimizationAndImprovement.md"},t=a(`<h2 id="css-优化和提高性能的方法有哪些" tabindex="-1">CSS 优化和提高性能的方法有哪些？ <a class="header-anchor" href="#css-优化和提高性能的方法有哪些" aria-label="Permalink to &quot;CSS 优化和提高性能的方法有哪些？&quot;">​</a></h2><p><strong>加载性能：</strong></p><ul><li><p>css <code>压缩</code>, 减小文件体积。</p></li><li><p>css <code>单一</code>样式 margin-bottom:bottom； margin-left:left；比 margin:top 0 bottom 0；执行效率高。</p></li><li><p>减少使用 <code>@import</code>，建议使用 <code>link</code>，因为 link 在页面加载时一起加载，import 是页面加载完成之后再加载。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>两者都是外部引用 CSS 的方式，它们的区别如下：</span></span>
<span class="line"><span>link 是 XHTML 标签，除了加载 CSS 外，还可以定义 RSS 等其他事务；  @import 只能加载 CSS。</span></span>
<span class="line"><span>link 引用 CSS 时，在页面载入时同时加载；  @import 需要页面网页完全载入以后加载。</span></span>
<span class="line"><span>link 是 XHTML 标签，无兼容问题；  @import 是在 CSS2.1 提出的，低版本的浏览器不支持。</span></span>
<span class="line"><span>link 支持使用 Javascript 控制 DOM 去改变样式；  @import 不支持。</span></span></code></pre></div></li></ul><p><strong>选择器性能：</strong></p><ul><li><code>关键</code>选择器, 减少层级, 最高不超过3层</li><li>尽量使用 <code>class</code>, 避免使用html标签选择</li><li>少使用<code>后代</code>选择器, 后代选择器<code>开销高</code></li><li>避免对<code>可继承</code>的属性<code>重复</code>定义</li><li>避免使用<code>通配</code>规则, 只对需要的元素进行处理\`</li></ul><p><strong>渲染性能：</strong></p><ul><li>慎重使用高性能属性：<code>浮动</code>、<code>定位</code>。</li><li>尽量减少页面<code>重排</code>、<code>重绘</code>。</li><li>属性值为 0 时，不加<code>单位</code>。</li><li>属性值为浮动小数 0.**，可以<code>省略</code>小数点之前的 0。</li><li>不使用 <code>@import</code> 前缀，它会影响 css 的<code>加载速度</code>。</li></ul><p><strong>可维护性：</strong></p><ul><li>抽离 <code>css</code>, 提高<code>可复用性</code>。</li><li>样式与内容<code>分离</code>, 提高<code>可维护性</code>。</li></ul><h2 id="对-css-工程化的理解" tabindex="-1">对 CSS 工程化的理解 <a class="header-anchor" href="#对-css-工程化的理解" aria-label="Permalink to &quot;对 CSS 工程化的理解&quot;">​</a></h2><p><strong>CSS 工程化是为了解决以下问题：</strong><code>宏观设计：</code> CSS代码如何组织、如何拆分、模块结构怎样设计？ <code>编码优化：</code> 怎样写出更好的 CSS ？ <code>构建：</code> 如何处理我的 CSS，才能让它的打包结果最优？ <code>可维护性：</code> 容易变更, 容易接手</p><p><strong>以下三个方向都是时下比较流行的、普适性非常好的 CSS 工程化实践：</strong><code>预处理器：</code> Less、 Sass 等； <code>后处理器：</code> PostCSS <code>Webpack loader 等</code> 。</p><p><strong>如何用 Webpack 实现对 CSS 的处理：</strong><code>css-loader：</code> 导入 CSS 模块，对 CSS 代码进行编译处理； <code>style-loader：</code> 创建 style 标签，把 CSS 内容写入标签。</p><p>在实际使用中，<code>css-loader 的执行顺序一定要安排在 style-loader 的前面</code>。因为只有完成了编译过程，才可以对 css 代码进行插入；若提前插入了未编译的代码，那么 webpack 是无法理解这坨东西的，它会无情报错。</p><h2 id="z-index-属性在什么情况下会失效" tabindex="-1">z-index 属性在什么情况下会失效 <a class="header-anchor" href="#z-index-属性在什么情况下会失效" aria-label="Permalink to &quot;z-index 属性在什么情况下会失效&quot;">​</a></h2><p>通常 <code>z-index</code> 的使用是在有两个<code>重叠</code>的标签，z-index 值越大就越是在上层。z-index 元素的 <code>position</code> 属性需要是 <code>relative</code>，<code>absolute</code> 或是 <code>fixed</code>。</p><p><strong>z-index 属性在下列情况下会失效：</strong></p><ul><li>父元素 position 为 <code>relative</code> 时，子元素的 z-index 失效。解决：父元素 position 改为 absolute 或 static；</li><li>元素没有设置 position 属性为非 static 属性。解决：设置该元素的 position 属性为 relative，absolute 或是 fixed；</li><li>元素在设置 z-index 的同时还设置了 <code>float</code> 浮动。解决：去除 float，改为 <code>display：inline-block</code>；</li></ul><h2 id="常见的-css-布局单位" tabindex="-1">常见的 CSS 布局单位 <a class="header-anchor" href="#常见的-css-布局单位" aria-label="Permalink to &quot;常见的 CSS 布局单位&quot;">​</a></h2><p><strong>像素px</strong> <code>基本</code>布局单位 <strong>百分比%</strong> ，相对于<code>父元素</code>的<code>百分比</code>，从而实现响应式的效果。 <strong>em</strong> 相对于父元素的文本的<code>倍数</code>。如果父元素未设置 <code>font-size</code>，则相对于浏览器的<code>默认</code>字体尺寸(默认 16px)。 <strong>rem</strong> 相对于根元素 <code>font-size</code> 的倍数。作用：利用 rem 可以实现简单的<code>响应式</code>布局，可以利用 html 元素中字体的大小与屏幕间的比值来设置 font-size 的值，以此实现当屏幕分辨率变化时让元素也随之变化。</p><p><strong>vw：</strong> 相对于视窗的宽度，视窗宽度是 100vw； <strong>vh：</strong> 相对于视窗的高度，视窗高度是 100vh； <strong>vmin：</strong> vw 和 vh 中的较小值； <strong>vmax：</strong> vw 和 vh 中的较大值；</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p><code>vw</code> 和百分比的区别是: <code>vw</code> 相对于视窗, <code>%</code> 相对于父元素</p></div><h2 id="px、em、rem-的区别及使用场景" tabindex="-1">px、em、rem 的区别及使用场景 <a class="header-anchor" href="#px、em、rem-的区别及使用场景" aria-label="Permalink to &quot;px、em、rem 的区别及使用场景&quot;">​</a></h2><p><strong>三者的区别：</strong></p><ul><li><code>px</code> 是固定的像素，一旦设置了就无法因为适应页面大小而改变。</li><li><code>em</code> 和 <code>rem</code> 相对于 px 更具有灵活性，他们是<code>相对</code>长度单位，其长度不是固定的，更适用于响应式布局。</li><li>em 是相对于其<code>父元素</code>来设置字体大小，这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小。而 rem 是相对于<code>根元素</code>，这样就意味着，只需要在根元素确定一个参考值。</li></ul><p><strong>使用场景：</strong></p><ul><li>对于只需要适配<code>少部分</code>移动设备，且分辨率对页面影响不大的，使用 <code>px</code> 即可 。</li><li>对于需要适配<code>各种</code>移动设备，使用 <code>rem</code>，例如需要适配 iPhone 和 iPad 等分辨率差别比较挺大的设备。</li></ul><h2 id="如何根据设计稿进行移动端适配" tabindex="-1">如何根据设计稿进行移动端适配？ <a class="header-anchor" href="#如何根据设计稿进行移动端适配" aria-label="Permalink to &quot;如何根据设计稿进行移动端适配？&quot;">​</a></h2><p>移动端适配主要有<code>两个</code>维度：</p><p><strong>适配不同像素密度</strong>，针对不同的<code>像素密度</code>，使用 CSS <code>媒体查询</code>，选择不同精度的图片，以保证图片不会<code>失真</code>； <strong>适配不同屏幕大小</strong>，由于不同的屏幕有着不同的<code>逻辑像素</code>大小，所以如果直接使用 <code>px</code> 单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会<code>失真</code>。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。</p><p>为了能让页面的尺寸自适应，可以使用 <code>rem</code>，<code>em</code>，<code>vw</code>，<code>vh</code> 等<code>相对单位</code>。</p><h2 id="响应式设计的概念及基本原理" tabindex="-1">响应式设计的概念及基本原理 <a class="header-anchor" href="#响应式设计的概念及基本原理" aria-label="Permalink to &quot;响应式设计的概念及基本原理&quot;">​</a></h2><p><code>响应式网站</code>是指一个网站能够<code>兼容多个终端</code>。</p><p><strong>关于原理：</strong> 基本原理是通过媒体查询（@media）查询检测不同的设备屏幕尺寸做处理。</p><p><strong>关于兼容：</strong> 页面头部必须有 <code>meta</code> 声明的 <code>viewport</code>。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">meta</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;viewport&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span></code></pre></div><h2 id="为什么需要清除浮动-清除浮动的方式" tabindex="-1">为什么需要清除浮动？清除浮动的方式 <a class="header-anchor" href="#为什么需要清除浮动-清除浮动的方式" aria-label="Permalink to &quot;为什么需要清除浮动？清除浮动的方式&quot;">​</a></h2><p><strong>浮动的定义</strong>： 非 IE 浏览器下，容器不设高度且子元素浮动时，容器高度不能被内容撑开。 此时，内容会溢出到容器外面而影响布局。这种现象被称为浮动（溢出）。</p><p><strong>浮动的工作原理：</strong></p><ul><li>浮动元素脱离文档流，不占据空间（引起“高度塌陷”现象）</li><li>浮动元素碰到包含它的边框或者其他浮动元素的边框停留</li></ul><p>浮动元素可以左右移动，直到遇到另一个浮动元素或者遇到它外边缘的包含框。浮动框不属于文档流中的普通流，当元素浮动之后，不会影响块级元素的布局，只会影响内联元素布局。此时文档流中的普通流就会表现得该浮动框不存在一样的布局模式。当包含框的高度小于浮动框的时候，此时就会出现“高度塌陷”。</p><p><strong>浮动元素引起的问题？</strong></p><ul><li>父元素的高度无法被撑开，影响与父元素同级的元素</li><li>与浮动元素同级的非浮动元素会跟随其后</li><li>若浮动的元素不是第一个元素，则该元素之前的元素也要浮动，否则会影响页面的显示结构</li></ul><h2 id="使用-clear-属性清除浮动的原理" tabindex="-1">使用 clear 属性清除浮动的原理？ <a class="header-anchor" href="#使用-clear-属性清除浮动的原理" aria-label="Permalink to &quot;使用 clear 属性清除浮动的原理？&quot;">​</a></h2><p>使用 clear 属性清除浮动，其语法如下：</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">clear: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">none</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">|left|right|both</span></span></code></pre></div><p>如果单看字面意思，clear:left 是“清除左浮动”，clear:right 是“清除右浮动”，实际上，这种解释是有问题的，因为浮动一直还在，并没有清除。</p><p>官方对 clear 属性解释：“元素盒子的边不能和前面的浮动元素相邻”，对元素设置 clear 属性是为了避免浮动元素对该元素的影响，而不是清除掉浮动。</p><p>还需要注意 clear 属性指的是元素盒子的边不能和前面的浮动元素相邻，注意这里“前面的”3 个字，也就是 clear 属性对“后面的”浮动元素是不闻不问的。考虑到 float 属性要么是 left，要么是 right，不可能同时存在，同时由于 clear 属性对“后面的”浮动元素不闻不问，因此，当 clear:left 有效的时候，clear:right 必定无效，也就是此时 clear:left 等同于设置 clear:both；同样地，clear:right 如果有效也是等同于设置 clear:both。由此可见，clear:left 和 clear:right 这两个声明就没有任何使用的价值，至少在 CSS 世界中是如此，直接使用 clear:both 吧。</p><p>一般使用伪元素的方式清除浮动：</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.clear::after</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  display</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">block</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  clear</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">both</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>clear 属性只有块级元素才有效的，而 ::after 等伪元素默认都是内联水平，这就是借助伪元素清除浮动影响时需要设置 display 属性值的原因。</p><h2 id="对-bfc-的理解-如何创建-bfc" tabindex="-1">对 BFC 的理解，如何创建 BFC <a class="header-anchor" href="#对-bfc-的理解-如何创建-bfc" aria-label="Permalink to &quot;对 BFC 的理解，如何创建 BFC&quot;">​</a></h2><p>先来看两个相关的概念：</p><ul><li>Box: Box 是 CSS 布局的对象和基本单位，⼀个⻚⾯是由很多个 Box 组成的，这个 Box 就是我们所说的盒模型。</li><li>Formatting context：块级上下⽂格式化，它是⻚⾯中的⼀块渲染区域，并且有⼀套渲染规则，它决定了其⼦元素将如何定位，以及和其他元素的关系和相互作⽤。</li></ul><p>块格式化上下文（Block Formatting Context，BFC）是 Web 页面的可视化 CSS 渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。</p><p>通俗来讲：BFC 是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。如果一个元素符合触发 BFC 的条件，则 BFC 中的元素布局不受外部影响。</p><p><strong>创建 BFC 的条件：</strong></p><ul><li>根元素：body；</li><li>元素设置浮动：float 除 none 以外的值；</li><li>元素设置绝对定位：position (absolute、fixed)；</li><li>display 值为：inline-block、table-cell、table-caption、flex 等；</li><li>overflow 值为：hidden、auto、scroll；</li></ul><p><strong>BFC 的特点：</strong></p><ul><li>垂直方向上，自上而下排列，和文档流的排列方式一致。</li><li>在 BFC 中上下相邻的两个容器的 margin 会重叠</li><li>计算 BFC 的高度时，需要计算浮动元素的高度</li><li>BFC 区域不会与浮动的容器发生重叠</li><li>BFC 是独立的容器，容器内部元素不会影响外部元素</li><li>每个元素的左 margin 值和容器的左 border 相接触</li></ul><p><strong>BFC 的作用：</strong></p><ul><li>解决 margin 的重叠问题：由于 BFC 是一个独立的区域，内部的元素和外部的元素互不影响，将两个元素变为两个 BFC，就解决了 margin 重叠的问题。</li><li>解决高度塌陷的问题：在对子元素设置浮动后，父元素会发生高度塌陷，也就是父元素的高度变为 0。解决这个问题，只需要把父元素变成一个 BFC。常用的办法是给父元素设置overflow:hidden。</li><li>创建自适应两栏布局：可以用来创建自适应两栏布局：左边的宽度固定，右边的宽度自适应。</li></ul><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;left&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;right&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.left{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     width: 100px;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     height: 200px;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     background: red;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     float: left;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> .right{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     height: 300px;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     background: blue;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     overflow: hidden;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><p>左侧设置float:left，右侧设置overflow: hidden。这样右边就触发了 BFC，BFC 的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠，实现了自适应两栏布局。</p><h2 id="什么是-margin-重叠问题-如何解决" tabindex="-1">什么是 margin 重叠问题？如何解决？ <a class="header-anchor" href="#什么是-margin-重叠问题-如何解决" aria-label="Permalink to &quot;什么是 margin 重叠问题？如何解决？&quot;">​</a></h2><p><strong>问题描述：</strong></p><p>两个块级元素的上外边距和下外边距可能会合并（折叠）为一个外边距，其大小会取其中外边距值大的那个，这种行为就是外边距折叠。需要注意的是，浮动的元素和绝对定位这种脱离文档流的元素的外边距不会折叠。重叠只会出现在垂直方向。</p><p><strong>计算原则：</strong></p><p>折叠合并后外边距的计算原则如下：</p><ul><li>如果两者都是正数，取大者</li><li>如果是一正一负，取正值减去负值的绝对值</li><li>两个都是负值时，取绝对值大者</li></ul><p><strong>解决办法：</strong></p><p>对于折叠的情况，主要有两种：<code>兄弟之间重叠</code>和<code>父子之间重叠</code></p><ol><li>兄弟之间重叠</li></ol><ul><li>底部元素变为行内盒子：display: inline-block</li><li>底部元素设置浮动：float</li><li>底部元素的 position 的值为absolute/fixed</li></ul><ol><li>父子之间重叠</li></ol><ul><li>父元素加入：overflow: hidden</li><li>父元素添加透明边框：border:1px solid transparent</li><li>子元素变为行内盒子：display: inline-block</li><li>子元素加入浮动属性或定位</li></ul><h2 id="元素的层叠顺序" tabindex="-1">元素的层叠顺序 <a class="header-anchor" href="#元素的层叠顺序" aria-label="Permalink to &quot;元素的层叠顺序&quot;">​</a></h2><p>层叠顺序，英文称作 stacking order，表示元素发生层叠时有着特定的垂直显示顺序。下面是盒模型的层叠规则：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4fb831e69f6e449eafa1f80afbc48dd7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>对于上图，由上到下分别是：</p><ol><li>背景和边框：建立当前层叠上下文元素的背景和边框。</li><li>负的 z-index：当前层叠上下文中，z-index 属性值为负的元素。</li><li>块级盒：文档流内非行内级非定位后代元素。</li><li>浮动盒：非定位浮动元素。</li><li>行内盒：文档流内行内级非定位后代元素。</li><li>z-index:0：层叠级数为 0 的定位元素。</li><li>正 z-index：z-index 属性值为正的定位元素。</li></ol><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>提示当定位元素 z-index:auto，生成盒在当前层叠上下文中的层级为 0，不会建立新的层叠上下文，除非是根元素。</p></div>`,83),o=[t];function n(p,d,c,r,h,k){return e(),s("div",null,o)}const u=i(l,[["render",n]]);export{E as __pageData,u as default};
